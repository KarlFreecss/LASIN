#include "memread.hpp"
#include "data_set.hpp"
#include "data_patch.hpp"
#include "models.hpp"
#include "utils.hpp"
#include "errors.hpp"
#include "../arff/arff_data.h"
#include "../arff/arff_parser.h"

#include <SWI-cpp.h>
#include <SWI-Prolog.h>
#include <mlpack/core.hpp>

#include <unistd.h>
#include <iostream>
#include <sstream>
#include <cstring>
#include <ctime>
#include <cmath>

using namespace std;
using namespace arma;
using namespace mlpack;

typedef HOEFF_TREE MODEL_TYPE;

/* stat_classifier(DataPatch, InRange, Model, OutRange)
 *   
 * train/eval a statistical classifier model with input dataset "DataPatch"
 * @DataPatch and @InRange defines the input
 * @Model is either input or output
 * @OutRange is the indices set in DataPatch that satisfies @Model
 *
PREDICATE(stat_classifier, 4) {
        
    term_t data_t = A1.ref;
    char *data_s;
    if (PL_get_atom_chars(data_t, &data_s)) {
        DataPatch *data_patch = str2ptr<DataPatch>(data_s);
        PlTail selector(A2);
        vector<uword> range_1 = parse_selector(selector);
        DataPatch data_train = data_patch->select_data(range_1);
        arma::Row<size_t> *labels = data_train.get_labels_type<size_t>();
        mat *train_set = data_train.get_features();
        // train a new classifier or test an old one?
        bool train = (A3.type() == PL_VARIABLE ? true : false);
        StatModel<MODEL_TYPE> *model;
        arma::Row<size_t> predictions;
        bool new_cls = true; // whether it is trained (new) or existed (old)
        if (train) { // if Arg3 is variable, abduce and train
            // abduce model
            StatModel<MODEL_TYPE> *best_temp_model;
            
            //double min_err = 100;
            double max_auc = -100;
            // try old classifiers
            PlTermv av(1);
            PlQuery query("classifier", av);
            while (query.next_solution()) {
                term_t temp_model_t = av[0].ref;
                char *temp_model_s;

                if (PL_get_atom_chars(temp_model_t, &temp_model_s)) {
                    cout << "Checking model: " << temp_model_s << ", ";
                    Stat_Model<MODEL_TYPE> *temp_model =
                        str2ptr<Stat_Model<MODEL_TYPE>>(temp_model_s);
                    arma::Row<size_t> temp_predictions;
                    temp_model->Classify(*train_set, temp_predictions);
                    //double temp_err = error_rate(*labels, temp_predictions);
                    double temp_auc = aucroc(*labels, temp_predictions);
                    //cout << "Err: " << temp_err << endl;
                    cout << "AUC: " << temp_auc << endl;
                    //
                    //if (temp_err < min_err) {
                    //    min_err = temp_err;
                    //    best_temp_tree = temp_model;
                    //    predictions = temp_predictions;
                    //}
                    //if (min_err < 0.001)
                    //    break;
                    //
                    if (temp_auc > max_auc) {
                        max_auc = temp_auc;
                        best_temp_model = temp_model;
                        predictions = temp_predictions;
                    }
                    if (max_auc > 0.99)
                        break;

                } else {
                    cerr << "Reading pointer " << (char*) av[0]
                         << " error!" << endl;
                    return FALSE;
                }
            }
            
            // train batch model
            if (is_same<MODEL_TYPE, HOEFF_TREE>::value)
                // tree
                model = new StatModel<MODEL_TYPE>(*(data_train.get_info()), 2);
            else if (is_same<MODEL_TYPE, ADABOOST_STUMP>::value)
                // adaboost
                model = new StatModel<MODEL_TYPE>();
            // train
            model->train(*train_set, *labels);
            // train eval
            arma::Row<size_t> temp_predictions;
            model->classify(*train_set, temp_predictions);
            //double train_err = error_rate(*labels, temp_predictions);
            double train_auc = aucroc(*labels, temp_predictions);
            //cout << "Train error: " << train_err << endl;
            cout << "Train auc: " << train_auc << endl;
            //if (min_err < 0.01 || min_err <= train_err) {
            if (max_auc > 0.99 || max_auc >= train_auc) {
                delete model; // if existed model is better, free memory of new model
                model = best_temp_model;
                new_cls = false;
            } else
                predictions = temp_predictions;
            
        } else { // if Arg3 is not variable, read model
            term_t model_t = A3.ref;
            char *model_s;
            if (PL_get_atom_chars(model_t, &model_s)) {
                model = str2ptr<StatModel<MODEL_TYPE>>(model_s);
                model->classify(*train_set, predictions);
            } else
                return LOAD_ERROR("stat_classifier/4", 3, "MODEL", "STRING");
        }

        // build a list
        term_t list_term_ref = PL_new_term_ref();
        PlTerm list_term(list_term_ref);
        PlTail pl_list(list_term);
        bool nocoverage = true;
        for (uword idx = 0; idx < predictions.n_elem; idx++) {
            if (predictions[idx] > 0) {
                pl_list.append((long) range_1[uword(idx)]);
                nocoverage = false;
            }
            else
                continue;
        }
        pl_list.close();
        // output
        if (nocoverage)
            return FALSE;
        if (train) {
            // build model term
            string model_addr = ptr2str(model);
            term_t model_term = PL_new_term_ref();
            if (PL_put_atom_chars(model_term, model_addr.c_str())) {
                A3 = PlTerm(model_term);
                if (new_cls) {
                    assert_classifier(A3);
                    cout << "Assertion of new statistical classifier: "
                         << model_addr << endl;
                } else
                    cout << "No assertion!" << endl;
                return A4 = list_term;
            } else {
                cerr << "Writing new classifier address error!" << endl;
                return FALSE;
            }
        } else
            return A4 = list_term;
    } else 
        return LOAD_ERROR("stat_classifier/4", 1, "DATA_ADD", "STRING");
}

/* write_model(Model, Archive).
 * save a statistical model to an archive
 * @Model: model pointer
 * @Archive: archive name(path)?
 *
PREDICATE(write_model, 2) {
    term_t t1 = A1.ref;
    char *p1;
    if (PL_get_atom_chars(t1, &p1)) {
        return TRUE;
    } else {
        cerr << "[write_model] Reading @Model error!" << endl;
        return FALSE;
    }
    
}

*/

