#include "data_set.hpp"
#include "data_patch.hpp"
#include "hyp.hpp"
#include "memread.hpp"
#include "../arff/arff_data.h"
#include "../arff/arff_parser.h"

#include <SWI-cpp.h>
#include <SWI-Prolog.h>

#include <boost/serialization/serialization.hpp>
#include <boost/archive/xml_iarchive.hpp>
#include <boost/archive/xml_oarchive.hpp>
#include <boost/archive/text_iarchive.hpp>
#include <boost/archive/text_oarchive.hpp>
#include <boost/archive/binary_iarchive.hpp>
#include <boost/archive/binary_oarchive.hpp>

#include <stdlib.h>

using namespace std;

int main(int argc, char **argv) {
    int label_idx = atoi(argv[1]);
    // initiate an prolog engine
    PlEngine PE(argv[0]);

    /*
    if (argc < 2) {
        cerr << "usage: " << argv[0] << " [trainning data]" << endl;
        exit(EXIT_FAILURE);
    }
    ArffParser parser(argv[1]);
    */
    ArffParser *parser = new ArffParser("../../data/hierarchy/cellcycle_FUN.train.arff");
    //ArffParser *parser = new ArffParser("../../data/test/case5.arff");
    ArffData* arff_data = parser->parse();
    cout << "arff parsed!" << "\n";
    MLDataSet data(arff_data);

    data.get_instance(0).print("instance 0: ");
    cout << data.get_inst_label(0, label_idx) << endl;
    //data.labels_column(label_idx).print("label 0: ");
    //data.labels_row(20).print("label row 0: ");
    cout << data.label_index("01") << endl;
    cout << data.num_instances() << endl;
    cout << data.num_labels() << endl;;
    cout << data.feature_name(20) << endl;
    cout << data.label_name(label_idx) << endl;

    DataPatch *data_patch = new DataPatch(data.data_with_label(label_idx));
    
    PlTerm sub1 = data.range_of_label(0);
    PlTerm sub2 = data.range_of_label(1);
    PlTermv *sub_arg = new PlTermv(1);
    (*sub_arg)[0] = sub1;
    cout << data.label_name(0) << " range: " << endl;
    PlCall("write", *sub_arg);
    PlCall("nl");
    cout << data.label_name(1) << " range: " << endl;
    delete sub_arg;
    sub_arg = new PlTermv(1);
    (*sub_arg)[0] = sub2;
    PlCall("write", *sub_arg);
    PlCall("nl");
    //cout << data.label_name(0) << " range: " << (char*) sub1 << endl;
    //cout << data.label_name(1) << " range: " << (char*) sub2 << endl;
    
    data_patch->get_features();
    cout << "patch: " << data_patch->size() << ", "
         << data_patch->get_labels()->n_cols << endl;
    

    /// test classifiers.so
    // data to prolog string
    PlCall("consult('../prolog/test.pl').");
    string data_addr = ptr2str(data_patch);
    std::cout << "C args: " + data_addr << std::endl;
    std::cout << "Data size: " << data_patch->size() << std::endl;
    term_t data_term = PL_new_term_ref();
    PL_put_atom_chars(data_term, data_addr.c_str());
    //PL_put_integer(data_term, label_idx);
    
    // prolog string to arguments
    PlTermv pl_args(1);
    //pl_args[0] = PlTerm(data_term);

    // init query
    //PlQuery q("test_cls", pl_args);
    PlQuery q("test_gogo", pl_args);
    
    // test query
    if(q.next_solution()) {
        cout << "Success!" << endl;
        cout << "Learned Program: " << endl;
        cout << (char*) pl_args[0] << endl;
        // @TODO::save ps(_,_,_,_).
        MyHyp<HOEFF_TREE> *hyp = new MyHyp<HOEFF_TREE>(data.get_info());
        hyp->parse_pl_hyp(pl_args[0]);

        // test serialization save
        std::ofstream ofs("test.bin", std::ios::binary);
        boost::archive::binary_oarchive o(ofs);
        try {
            o << mlpack::data::CreateNVP(*hyp, "hyp");
        }
        catch (boost::archive::archive_exception& e) {
            cerr << "serialization failed." << endl;
        }
        ofs.close();
        cout << "serialization success!" << endl;
        // test serialization load
        try {
            MyHyp<HOEFF_TREE> *another_hyp = new MyHyp<HOEFF_TREE>();
            std::ifstream ifs("test.bin", std::ios::binary);
            boost::archive::binary_iarchive is(ifs);
            try {
                is >> mlpack::data::CreateNVP(*another_hyp, "another_hyp");
            } catch (boost::archive::archive_exception& e) {
                cerr << "unserialization failed." << endl;
            }
            ifs.close();
            cout << "unserialization success!" << endl;

            //another_hyp->update_stat_model_addrs();
            //vector<string> mss = another_hyp->get_metasubs();
            //vector<string> msa = another_hyp->get_model_addrs();
            vector<StatModel<HOEFF_TREE>> stat_ms = another_hyp->get_stat_models();
            cout << "MetaSubs: " << endl;
            /*
            for (auto it = mss.begin(); it != mss.end(); ++it) {
                cout << *it << endl;
            }
            */
            cout << "Model Addr: " << endl;
            int idx = -1;
            for (auto it = another_hyp->get_stat_models().begin(); it != another_hyp->get_stat_models().end(); ++it) {
                idx++;
                //shark::RFClassifier *m = new shark::RFClassifier();
                // *m = (shark::RFClassifier) *it;
                void *p = another_hyp->get_stat_models().data() + (it - another_hyp->get_stat_models().begin());
                string m_add = ptr2str(p);
                cout << m_add << " : ";
                //cout << msa[idx] << endl;
            }
            cout << "Hypothesis regeneration:" << endl;
            cout << (char *) another_hyp->to_prolog_hyp() << endl;
            cout << (char *) another_hyp->to_prolog_hyp() << endl;
            cout << (char *) another_hyp->to_prolog_hyp() << endl;
            // evaluate
            PlTermv test_args(1);
            test_args[0] = another_hyp->to_prolog_hyp();
            PlQuery q2("test_eval_gogo", test_args);
            q2.next_solution();
        } catch (...) {
            cout << "Input serialized archive failed!" << endl;
        }
    } else
        cout << "Failed!" << endl;

    /// clear memory
    delete parser;
    arff_data = NULL;
    delete data_patch;
    data_patch = NULL;
    
    //vector<string> pl_fathers = data.pl_label_relation();
    //data.print_label_relation("../prolog/bk.pl");
    return 0;
}
